#!/usr/bin/python

# Copyright (C) 2008-2010 by CiscoRx
# Copyright (C) 2010 by Travis B. Hartwell
#
# This file is part of Emacs Google Calendar Sync
#
# Emacs Google Calendar Sync is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.
#
# Emacs Google Calendar Sync is distributed in the hope that it will
# be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Emacs Google Calendar Sync.  If not, see
# <http://www.gnu.org/licenses/>.

"""Synchronize an Emacs diary file and a Google hosted calendar.

Usage:
    emacs-google-calendarsync [options]

Where:
    --config-file=file
    -c file
        The location of the optional configuration file to use.  If
        none is specified, the program checks for ~/.egc-sync.ini.  If
        this file does not exist, the user will be prompted for the
        required information.

    --verbose
    -v
        If set, output verbose debugging information.

    --help
    -h
        Print this help message and exit.

This initial pass merely takes the data from the specific Google
calendar and converts it into Emacs diary format, overwriting the
existing file, if any.

"""
import getopt
import os
import sys
from ConfigParser import NoOptionError, NoSectionError, SafeConfigParser

from calendarsync import sync, config, util


# Defaults
DEFAULT_CONFIG_FILE_NAME = '.egc-sync.ini'
DEFAULT_CONFIG_PATH = \
    os.path.expanduser(os.path.join('~', DEFAULT_CONFIG_FILE_NAME))

# Command line parsing constants
LONG_OPTS = ['help',
             'config-file=',
             'verbose']
SHORT_OPTS = 'hcv'
CONFIG_FILE_VAR = 'config_file'

# Configuration file section name constants
GCAL_SECTION_NAME = 'Google Calendar'
EMACS_DIARY_SECTION_NAME = 'Emacs Diary'

# Exit status
NO_ERROR_EXIT_STATUS = 0
CMDLINE_OPTS_EXIT_STATUS = 1
INVALID_CONFIG_FILE_EXIT_STATUS = 2



def usage(status, msg=''):
    """Show the usage defined in the script docstring, an optional
    error message, and then exit with the specified status code.
    """
    # Shamelessly borrowed from GNU Mailman code
    if status:
        fd = sys.stderr
    else:
        fd = sys.stdout
    print >> fd, __doc__
    if msg:
        print >> fd, msg
    sys.exit(status)



def parse_cmdline(argv):
    """Parse the command line specified by the list argv, returning
    the options set.
    """
    # Set defaults
    options = {}
    options[CONFIG_FILE_VAR] = DEFAULT_CONFIG_PATH

    try:
        # Currently ignoring the args returned, do something with it
        # when parameters allow for arguments.
        opts, _ = getopt.getopt(argv, SHORT_OPTS, LONG_OPTS)
    except getopt.GetoptError, err:
        usage(CMDLINE_OPTS_EXIT_STATUS, str(err))

    for option, arg in opts:
        if option in ('-h', '--help'):
            usage(NO_ERROR_EXIT_STATUS)
        elif option in ('-c', '--config-file'):
            if arg in (None, ''):
                usage(CMDLINE_OPTS_EXIT_STATUS,
                      'Missing config file name argument to option.')
            else:
                options[CONFIG_FILE_VAR] = arg
        elif option in ('-v', '--verbose'):
            options[config.VERBOSE_VAR] = True
        else:
            usage(CMDLINE_OPTS_EXIT_STATUS,
                  'Unhandled option: %s.' % option)

    # Add 'args' to options before returning?
    return options



def get_configuration_item(config_parser, section, var, required=True):
    """Gets the configuration item specified by section and var from
    config_parser.  Will exit the program with an error if required is
    True and the section or option are not found.
    """
    try:
        value = config_parser.get(section, var)
    except NoSectionError:
        if required:
            print "Missing section named: %s." % section
            sys.exit(INVALID_CONFIG_FILE_EXIT_STATUS)
    except NoOptionError:
        if required:
            print "Missing option %s in section %s." % (var, section)
            sys.exit(INVALID_CONFIG_FILE_EXIT_STATUS)

    return value



def get_configuration(config_file_name):
    """Parses the configuration file specified by config_file_name.
    Returns a dictionary with the resulting configuration.
    """
    if not os.path.exists(config_file_name):
        print 'Configuration file %s not found.' % config_file_name
        sys.exit(INVALID_CONFIG_FILE_EXIT_STATUS)

    config_parser = SafeConfigParser()
    config_parser.read(config_file_name)

    configuration = {}
    configuration[config.GCAL_USERNAME_VAR] = \
        get_configuration_item(config_parser,
                               GCAL_SECTION_NAME,
                               config.GCAL_USERNAME_VAR)

    configuration[config.GCAL_PASSWORD_VAR] = \
        get_configuration_item(config_parser,
                               GCAL_SECTION_NAME,
                               config.GCAL_PASSWORD_VAR)

    configuration[config.EMACS_DIARY_PATH_VAR] = \
        get_configuration_item(config_parser,
                               EMACS_DIARY_SECTION_NAME,
                               config.EMACS_DIARY_PATH_VAR,
                               False)

    if configuration[config.EMACS_DIARY_PATH_VAR] is not None:
        configuration[config.EMACS_DIARY_PATH_VAR] = \
            os.path.expanduser(configuration[config.EMACS_DIARY_PATH_VAR])

    return configuration



def main(argv=None):
    """Get the configuration from the command line arguments and the
    configuration file and then call the synchronization method.
    """
    if argv is None:
        argv = sys.argv[1:]

    options = parse_cmdline(argv)
    configuration = get_configuration(options[CONFIG_FILE_VAR])

    # Combine options from configuration file, command line options,
    # and defaults for items not set
    configuration.update(options)
    configuration = config.update_configuration(configuration)

    # Do some general set up before launching the synchronization
    # TODO: Does this belong in sync.run_synchronization?
    util.init_logging(configuration)

    sync.run_synchronization(configuration)


if __name__ == '__main__':
    main()
